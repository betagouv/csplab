"""External document gateway implementation."""

from datetime import datetime, timezone
from typing import List, Tuple, cast

from asgiref.sync import async_to_sync

from domain.entities.document import Document, DocumentType
from domain.gateways.document_gateway_interface import IDocumentGateway
from domain.services.http_client_interface import IHttpClient
from domain.services.logger_interface import ILogger
from domain.types import JsonDataType
from infrastructure.external_gateways.dtos.ingres_corps_dtos import (
    IngresCorpsApiResponse,
)
from infrastructure.external_gateways.talentsoft_client import TalentsoftFrontClient


class ExternalDocumentGateway(IDocumentGateway):
    """Fetches documents from external API sources."""

    def __init__(
        self,
        piste_client: IHttpClient,
        talentsoft_front_client: TalentsoftFrontClient,
        logger_service: ILogger,
    ):
        """Initialize with PISTE client, logger and source."""
        self.piste_client = piste_client
        self.talentsoft_front_client = talentsoft_front_client
        self.logger = logger_service
        self._source = {
            DocumentType.CORPS: self._fetch_ingres_api,
            DocumentType.GRADE: self._fetch_ingres_api,
            DocumentType.OFFERS: self._fetch_talentsoft_api,
            # TODO
            # DocumentType.CONCOURS: self._fetch_from_csv,
            # DocumentType.LAW_CONCOURS: self._fetch_legifrance_sdk,
            # DocumentType.LAW_CORPS: self._fetch_legifrance_sdk,
        }

    def fetch_by_type(
        self, document_type: DocumentType, start: int = 1, batch_size: int = 1000
    ) -> Tuple[List[Document], bool]:
        """Fetch documents from external source."""
        self.logger.info(f"Fetching documents of type {document_type}")

        source = self._source.get(document_type)
        if not source:
            raise ValueError(f"No fetch source for {document_type}")

        raw_documents, has_more = source(document_type, start)
        now = datetime.now(timezone.utc)

        documents = []

        if document_type == DocumentType.OFFERS:
            # For OFFERS, raw_documents is already a list of Document objects
            return cast(List[Document], raw_documents), has_more

        if document_type == DocumentType.CORPS:
            typed_raw_documents = cast(List[dict], raw_documents)
            validated_response = IngresCorpsApiResponse.from_list(typed_raw_documents)

            for validated_doc in validated_response.documents:
                document = Document(
                    external_id=str(validated_doc.identifiant),
                    raw_data=validated_doc.model_dump(),
                    type=document_type,
                    created_at=now,
                    updated_at=now,
                    # id will be auto-generated by Document entity
                )
                documents.append(document)

        return documents, has_more

    def _fetch_ingres_api(
        self, document_type: DocumentType, start: int = 1
    ) -> Tuple[List[JsonDataType], bool]:
        document_type_map = {
            DocumentType.CORPS: "CORPS",
            DocumentType.GRADE: "GRADE",
        }

        endpoint = document_type_map.get(document_type)
        if endpoint is None:
            raise ValueError(f"Ingres: unknown document type: {document_type}")

        response = self.piste_client.request(
            "GET", endpoint, params={"enVigueur": "true", "full": "true"}
        )

        raw_documents = response.json()["items"]
        self.logger.info(f"Found {len(raw_documents)} documents")

        has_more = False
        return cast(List[JsonDataType], raw_documents), has_more

    async def _fetch_offers(self, start: int):
        """Init talentsoft_front_client with async context."""
        async with self.talentsoft_front_client:
            return await self.talentsoft_front_client.get_offers(start=start)

    def _fetch_talentsoft_api(
        self, document_type: DocumentType, start: int = 1
    ) -> Tuple[List[Document], bool]:
        """Fetch documents from talensoft front external source."""
        if document_type != DocumentType.OFFERS:
            raise ValueError(
                f"Talentsoft Front API: unsupported document type: {document_type}"
            )

        # TODO remove `async_to_sync` as soon as piste_client is _asynced_ !
        # Convert async method to sync using Django's async_to_sync
        # with proper context manager
        sync_fetch_offers = async_to_sync(self._fetch_offers)

        # Run async method in sync context
        try:
            raw_documents, has_more = sync_fetch_offers(start)
        except Exception as e:
            self.logger.error("Failed to fetch offers from Talentsoft: %s", e)
            return [], False

        if not isinstance(raw_documents, list):
            self.logger.error("Expected list of documents, got %s", type(raw_documents))
            return [], False

        self.logger.info(
            "Found %d offers from Talentsoft Front API", len(raw_documents)
        )

        now = datetime.now(timezone.utc)
        documents = []

        for raw_doc in raw_documents:
            reference = raw_doc.reference
            if reference is None:
                self.logger.warning("Skipping raw_doc without reference: %s", raw_doc)
                continue

            versant_code_obj = raw_doc.salaryRange
            versant = versant_code_obj.clientCode if versant_code_obj else "UNK"

            external_id = f"{versant}-{reference}"

            document = Document(
                external_id=external_id,
                raw_data=raw_doc.model_dump(),  # convert TalensoftOffer obj into dict
                type=document_type,
                created_at=now,
                updated_at=now,
                # id will be auto-generated by Document entity
            )
            documents.append(document)

        return documents, has_more
